---
title: "SQL en R con el paquete sqldf (parte II) (En construcción)"
author: "Rubén F. Bustillo"
date: 2019-12-05
categories: ["R"]
tags: ["SQL", "sqldf"]

---



<p><strong>Re</strong></p>
<p>Este post s una continuación del post anterior en el que expusimos cómo realizar operaciones en R utilizando la sintaxis tradicional de SQL con la función <code>sqldf()</code>, única función del paquete {sqldf}.</p>
<p><br />
</p>
<div id="paquetes" class="section level1">
<h1>Paquetes</h1>
<p><br />
</p>
<p>En primer lugar descargamos el paquete {sqldf} y el paquete {tidyverse} que nos servirá para comparar la sintaxis de SQL con la sintaxis tradicional de {dplyr}. En <a href="https://rquer.netlify.com/babynames/">este post anterior</a> se expone en mayor profundidad las principales funcionalidades del paquete {tidyverse}.</p>
<p><br />
</p>
<pre class="r"><code>
library(sqldf)
library(tidyverse)
library(gapminder)</code></pre>
</div>
<div id="introducción" class="section level1">
<h1>Introducción</h1>
<p><br />
</p>
<p>En este segundo post, que continúa la exposición de cómo trabajar con la sintaxis de SQL en R gracias al paquete {sqldf} que iniciamos en el post previo, vamos a explicar <strong>cómo unir tablas y cómo compilar información de diferentes fuentes</strong>.</p>
<p><br />
</p>
<p>Compilar información en una tabla proveniente de varias tablas es un aspecto fundamental en el análisis de datos. Aunque a día de hoy todavía no hemos realizado un post específico explicando cómo hacer estas operaciones en R -aunque todo se andará- en varios post hemos realizado uniones de diferentes datasets. (por ejemplo <a href="https://rquer.netlify.com/nuts/">aquí</a>, <a href="https://rquer.netlify.com/eurostat/">aquí</a> o <a href="https://rquer.netlify.com/mapas_spain/">aquí</a>). No obstante, aunque dejo la explicación de cómo realizar uniones de dataframes en R para una futura entrada, en este post realizaremos estas operaciones utilizando la sintaxis y el lenguage de SQL utilizando, de nuevo, el paquete {sqldf}.</p>
<p><br />
</p>
<p>A la hora de unir tablas o dataframes existen diversos aspectos que debemos tener en cuenta y dependerá de nuestros dataframes originales y del resultado que buscamos conseguir al realizar las uniones. Por ello existen diversos tipos de unión que, evidentemente, recibirán diferentes nombres. Intentaremos a lo largo del post abordar las diferentes posibilidades utilizando información de algunos países procedentes del dataset <code>gapminder</code> del paquete del mismo nombre.</p>
<p><br />
</p>
<p>El paquete gapminder ofrece varios dataframes referentes a un cojunto importante de países. El dataframe filtrado le han denominado <code>gapminder</code>:</p>
<p><br />
</p>
<pre class="r"><code>
gapminder::gapminder
## # A tibble: 1,704 x 6
##    country     continent  year lifeExp      pop gdpPercap
##    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1 Afghanistan Asia       1952    28.8  8425333      779.
##  2 Afghanistan Asia       1957    30.3  9240934      821.
##  3 Afghanistan Asia       1962    32.0 10267083      853.
##  4 Afghanistan Asia       1967    34.0 11537966      836.
##  5 Afghanistan Asia       1972    36.1 13079460      740.
##  6 Afghanistan Asia       1977    38.4 14880372      786.
##  7 Afghanistan Asia       1982    39.9 12881816      978.
##  8 Afghanistan Asia       1987    40.8 13867957      852.
##  9 Afghanistan Asia       1992    41.7 16317921      649.
## 10 Afghanistan Asia       1997    41.8 22227415      635.
## # ... with 1,694 more rows</code></pre>
<p><br />
</p>
<p>Un segundo dataset (<code>continent_colors</code>) contiene los colores que han asignado a cada continente:</p>
<p><br />
</p>
<pre class="r"><code>
gapminder::continent_colors
##    Africa  Americas      Asia    Europe   Oceania 
## &quot;#7F3B08&quot; &quot;#A50026&quot; &quot;#40004B&quot; &quot;#276419&quot; &quot;#313695&quot;</code></pre>
<p><br />
</p>
<p>Un tercer dataset (<code>country_codes</code>) contiene información sobre los códigos de los países</p>
<p><br />
</p>
<pre class="r"><code>
gapminder::country_codes
## # A tibble: 187 x 3
##    country     iso_alpha iso_num
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;
##  1 Afghanistan AFG             4
##  2 Albania     ALB             8
##  3 Algeria     DZA            12
##  4 Angola      AGO            24
##  5 Argentina   ARG            32
##  6 Armenia     ARM            51
##  7 Aruba       ABW           533
##  8 Australia   AUS            36
##  9 Austria     AUT            40
## 10 Azerbaijan  AZE            31
## # ... with 177 more rows</code></pre>
<p><br />
</p>
<p>Y un cuarto dataframe (<code>gapminder_unfiltered</code>) contiene una mayor información que el dataset <code>gapminder</code>. Este data frame sin filtrar está compuesto por 3313 observaciones mientras que el paquete <code>gapminder</code> se conforma por 1704.</p>
<p><br />
</p>
<pre class="r"><code>
gapminder::gapminder_unfiltered
## # A tibble: 3,313 x 6
##    country     continent  year lifeExp      pop gdpPercap
##    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1 Afghanistan Asia       1952    28.8  8425333      779.
##  2 Afghanistan Asia       1957    30.3  9240934      821.
##  3 Afghanistan Asia       1962    32.0 10267083      853.
##  4 Afghanistan Asia       1967    34.0 11537966      836.
##  5 Afghanistan Asia       1972    36.1 13079460      740.
##  6 Afghanistan Asia       1977    38.4 14880372      786.
##  7 Afghanistan Asia       1982    39.9 12881816      978.
##  8 Afghanistan Asia       1987    40.8 13867957      852.
##  9 Afghanistan Asia       1992    41.7 16317921      649.
## 10 Afghanistan Asia       1997    41.8 22227415      635.
## # ... with 3,303 more rows</code></pre>
<p><br />
</p>
<p>En este post no vamos a utilizar la totalidad de los dataframes arriba expuestos. Como el objetivo de esta entrada consiste en explicar las distintas modalidades, o joins, y exponer su forma de llevarlas a cabo en SQL, construiremos distintos subsets, partiendo de la información existente en los dataframes de {gapminder}, esperando que nuestros subsets nos permitan ejemplificar los distintos ejercicios de una forma más clara.</p>
<p><br />
</p>
</div>
<div id="inner-join" class="section level1">
<h1>INNER JOIN</h1>
<p><br />
</p>
<p>Supongamos que tenemos dos datasets, el primero con información sobre el PIB per cápita de una serie de países y el segundo con información sobre la esperanza de vida. No obstante los países del primer dataset (left table) y el segundo (right table) no coinciden. En el caso de que queramos generar un dataset donde tengamos información tanto del PIB per cápita como de la esperanza de vida, pero <strong>únicamente incluyendo los países que están en ambos datasets</strong> utilizaremos el comando INNER JOIN</p>
<p><br />
</p>
<p>El <strong>planteamiento general del INNER JOIN</strong> sería el que se observa en la figura. Vemos que el dataframe final solo incluye a los cuatros países presentes en ambas tablas (Australia, Canadá, Japón y España), excluyendo al resto de países, y la información de la segunda tabla (RIGTH TABLE) se une a la información presente en la primera (LEFT TABLE).</p>
<p><img src="/joins_SQL_files/figure-html/unnamed-chunk-6-1.png" width="100%" /></p>
<p>Aunque el anterior es el esquema general, existen algunos aspectos que debemos tener en cuenta. Veámoslo con una serie de ejemplos. En primer lugar vamos a realizar <strong>dos subsets que incluya los mismos países de los del dibujo previo</strong>, uno con información del PIB per cápita y otro con información de la esperanza de vida de dichos países.</p>
<p><br />
</p>
<pre class="r"><code>
# LEFT TABLE
vab_pc &lt;- gapminder %&gt;%
  filter(year == 2007) %&gt;%
  filter(country %in% c(&quot;Spain&quot;, &quot;Peru&quot;, &quot;India&quot;, &quot;Australia&quot;, &quot;Japan&quot;, &quot;Canada&quot;)) %&gt;%
  select(country, continent, gdpPercap)

# RIGHT TABLE 
life_exp &lt;- gapminder %&gt;%
  filter(year == 2007) %&gt;%
  filter(country %in% c(&quot;Spain&quot;, &quot;Australia&quot;, &quot;Singapore&quot;, &quot;Canada&quot;, &quot;Japan&quot;, &quot;Mongolia&quot;, &quot;Brazil&quot;)) %&gt;%
  select(country, continent, lifeExp)</code></pre>
<p><br />
</p>
<p>Veámos <strong>ambos datasets</strong>:</p>
<p><br />
</p>
<pre class="r"><code>vab_pc
## # A tibble: 6 x 3
##   country   continent gdpPercap
##   &lt;fct&gt;     &lt;fct&gt;         &lt;dbl&gt;
## 1 Australia Oceania      34435.
## 2 Canada    Americas     36319.
## 3 India     Asia          2452.
## 4 Japan     Asia         31656.
## 5 Peru      Americas      7409.
## 6 Spain     Europe       28821.

life_exp
## # A tibble: 7 x 3
##   country   continent lifeExp
##   &lt;fct&gt;     &lt;fct&gt;       &lt;dbl&gt;
## 1 Australia Oceania      81.2
## 2 Brazil    Americas     72.4
## 3 Canada    Americas     80.7
## 4 Japan     Asia         82.6
## 5 Mongolia  Asia         66.8
## 6 Singapore Asia         80.0
## 7 Spain     Europe       80.9</code></pre>
<p><br />
</p>
<p>Si queremos unir integramente el RIGHT TABLE al LEFT TABLE podemos indicar lo siguiente:</p>
<p><br />
</p>
<pre class="r"><code>
sqldf(&#39;SELECT *
      FROM vab_pc 
      INNER JOIN life_exp 
      ON vab_pc.country = life_exp.country&#39;)
##     country continent gdpPercap country..4 continent..5 lifeExp
## 1 Australia   Oceania  34435.37  Australia      Oceania  81.235
## 2    Canada  Americas  36319.24     Canada     Americas  80.653
## 3     Japan      Asia  31656.07      Japan         Asia  82.603
## 4     Spain    Europe  28821.06      Spain       Europe  80.941</code></pre>
<p><br />
</p>
<p>No obstante, en este caso un dataset se ha unido al anterior, aunque únicamente los países que coinciden en ambos, pero el resultado final incluye columnas repetidas que no nos interesan. Para conseguir un dataframe que se asemeje al del dibujo presentado arriba (con cuatro columnas únicamente) debemos realizar un serie de modificaciones. Indicaremos que queremos cuatro columnas, las dos primeras al estar repetidas serán las pertenecientes al primer dataset (p1),</p>
<p><br />
</p>
<pre class="r"><code>
sqldf(&#39;SELECT p1.country, p1.continent, gdpPercap, lifeExp
      FROM vab_pc AS p1
      INNER JOIN life_exp AS p2
      ON p1.country = p2.country&#39;)
##     country continent gdpPercap lifeExp
## 1 Australia   Oceania  34435.37  81.235
## 2    Canada  Americas  36319.24  80.653
## 3     Japan      Asia  31656.07  82.603
## 4     Spain    Europe  28821.06  80.941</code></pre>
<p><br />
</p>
<p>Puede que queramos unir más de dataframe en un solo comando. Pongamos por ejemplo que queramos incluir los códigos de cada país, que como vimos están presentes en un dataframe denominado <code>country_codes</code>. <strong>Para unir los tres dataframes</strong>, situando los códigos en la primera columna del nuevo dataset, no es necesario realizar primero una unión y luego la segunda sino que podemos realizar la operación conjuntamente.</p>
<p><br />
</p>
<p><strong>Guardamos el nuevo dataframe</strong> con el nombre <code>codes</code>.</p>
<p><br />
</p>
<pre class="r"><code>
codes &lt;- gapminder::country_codes</code></pre>
<p><br />
</p>
<p>Y realizamos una operación similar a la realizada previamente pero <strong>estableciendo dos INNER JOIN diferentes</strong>.</p>
<p><br />
</p>
<pre class="r"><code>
sqldf(&#39;SELECT iso_alpha AS code, p1.country, p1.continent, gdpPercap, lifeExp
      FROM vab_pc AS p1
      INNER JOIN life_exp AS p2
      ON p1.country= p2.country
      INNER JOIN codes AS p3
      ON p1.country = p3.country&#39;)
##   code   country continent gdpPercap lifeExp
## 1  AUS Australia   Oceania  34435.37  81.235
## 2  CAN    Canada  Americas  36319.24  80.653
## 3  JPN     Japan      Asia  31656.07  82.603
## 4  ESP     Spain    Europe  28821.06  80.941</code></pre>
<p><br />
</p>
<p>Como en nuestro caso el nombre de las columnas que utilizamos para la unión es el mismo <code>country</code> podemos, alternativamente, establecer USING seguido por el nombre de la variable entre paréntesis (en nuestro caso <code>country</code>) para una mayor sencillez del código. El resultado, como vemos, es el mismo.</p>
<p><br />
</p>
<pre class="r"><code>
sqldf(&#39;SELECT iso_alpha AS code, p1.country, p1.continent, gdpPercap, lifeExp
      FROM vab_pc AS p1
      INNER JOIN life_exp AS p2
      USING (country)
      INNER JOIN codes AS p3
      USING (country)&#39;)
##   code   country continent gdpPercap lifeExp
## 1  AUS Australia   Oceania  34435.37  81.235
## 2  CAN    Canada  Americas  36319.24  80.653
## 3  JPN     Japan      Asia  31656.07  82.603
## 4  ESP     Spain    Europe  28821.06  80.941</code></pre>
</div>
